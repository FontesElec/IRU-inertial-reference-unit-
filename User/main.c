/*
Автор: Чудаков Максим 
e-mail: fontes35@mail.ru
Дата создания: 02.11.2021
Версия 2.7.5

Взаимодействие между mpu9250 и stm32f103C8T6 по spi, получение первичных параметров Nx,Ny,Nz,Wx,Wy,Wz,Bx,By,Bz 
перерасчёт в глобальную систему координат и отправка по I2C (скорость 400 кГц) скорректированых на глобальные оси значений ускорений и углов.

!!!НУЖНО ВНЕСТИ КАЛИБРОВКУ СМЕЩЕНИЯ НУЛЕЙ АКСЕЛЕРОМЕТРА, ТЕКУЩАЯ ПРОИЗВЕДЕНА ВРУЧНУЮ И НЕВЕРНА ДЛЯ ЛЮБОГО ДРУГОГО ЧИПА

Изменения:
* вычистка лишнего кода

*/


#include "stm32f10x.h"                                      // Device header
#include "main.h"
#include "math.h"                       
#include "mpu9250.h"                                        // Описание функций работы с датчиком
#include "mpu9250Registers.h"                               // Адреса регистров датчика
#include "mpu9250.c"                                        // Функции работы с датчиком MPU9250
#include "mpu9250UserSettings.h"                            // Пользовательские настройки работы MPU9250
#include "sysTickSTM32F10x.c"                               // Настройки таймера
#include "sysTickSTM32F10x.h"                               // Настройки таймера
#include "iruFunctions.h"                                   // Математика
#include "iruFunctions.c"                                   // Математика
#include "stm32f10xi2c.h"                                   // Настройка и работа по шине i2c
#include "stm32f10xi2c.c"                                   // Настройка и работа по шине i2c
#include "iruInterruptions.c"                               // Описание векторов прерываний




//=================================== ОСНОВНОЙ БЛОК ================================
int main(void)
{
       
   
  MPU9250_SPI_INIT();
  I2C_Init();
  
  
    
    
  gi0=1;//стартовая настройка
  gi1=0;
  gi2=0;
  gi3=0;  

  //ПРЕДВАРИТЕЛЬНО ЗАПУСТИМ МАГНИТОМЕТР И ЗАПРОСИМ ЗАПИСЬ ПАРАМЕТРОВ ВО ВНУТРЕННИЕ РЕГИСТРЫ MPU, ПРОЧИТАЕМ ПОЛУЧЕННЫЕ ДАННЫЕ ПОЗДНЕЕ
                
        
        
        SPI_SET_PARAM_8BIT (I2C_SLV0_REG,3);                                        //загружаем адрес регистра AK8963
        SPI_SET_PARAM_8BIT (I2C_SLV0_ADDR,(MAG_I2C_SLV_ADDR|I2C_READ_SLV));         //магинтометр на slave0 в режиме чтения
        SPI_SET_PARAM_8BIT (I2C_SLV0_CTRL,(I2C_SLV0_EN|7));                         //доступ к slave0, настройка длины пакета данных
    
      
        for(int i=24; i>0;i--)                                                      //костыль, первый 24 раза датчик отправляет нули для магнитометра
        {
            GET_PARAM(); 
        }
        AK8963_CALIB();
      
  
   //======================== НАЧАЛЬНАЯ ВЫСТАВКА ОСЕЙ =========================        
          
        
        GET_PARAM();
        
        
        N=sqrt(Nx*Nx+Ny*Ny+Nz*Nz);
        pitch_n=180*asin(Nx/N)/M_PI;  
        roll_n=180*atan2(-Nz,Ny)/M_PI;       
        heading_m=180*atan2(Bz,Bx)/M_PI;
        if (heading_m < 0) {heading_m+=360;}
        
        heading=heading_m;
        roll=0;
        pitch=0;
        
        GET_QUATERNION(heading_m,0,0);//получение кватерниона углового положения через данные с акселерометра 
        
        gi0=x0;//стартовая настройка
        gi1=x1;
        gi2=x2;
        gi3=x3;     

        

   //======================= НАСТРОЙКА и ЗАПУСК ТАЙМЕРА =======================

      SysTick_Settings();
      SysTick->VAL=0;   //сбросим текущее значение счётчика в SYST_CVR
      uint16_t safe_time=SystemCoreClock/1000000*SAFE_TIME;
      
   //----------------------- НАСТРОЙКА и ЗАПУСК ТАЙМЕРА -----------------------
   
   //------------------------ НАЧАЛЬНАЯ ВЫСТАВКА ОСЕЙ -------------------------   
   
    
    while(1)
    {
              
        lock_cycle=1;//взводим флаг ожидания цикла
        
        GET_PARAM();
           
     //ОБНОВЛЕНИЕ ДАННЫХ      
        
        g0=gi0;
        g1=gi1;
        g2=gi2;
        g3=gi3;       
        
        
        
        //=================== ПОВОРАЧИВАЕМ ТЕКУЩИЙ КВАТЕРНИОН УГЛОВОГО ПОЛОЖЕНИЯ =============
        
        GET_QUATERNION(ay,ax,az);//получаем кватерион локального поворота по данным с ДУС-а    

        /* 
            Имея исходный кватернион G(g0,g1,g2,g3) положения объекта и кватернион локального поворота X(x0,x1,x2,x3)
          можно вычислить новое положение, перемножив два кватерниона Gc=G*X
        */ 
        
        gc0=g0*x0-g1*x1-g2*x2-g3*x3;//получаем кватернион углового положения с помощью данных с ДУС
        gc1=g0*x1+g1*x0+g2*x3-g3*x2;
        gc2=g0*x2-g1*x3+g2*x0+g3*x1;
        gc3=g0*x3+g1*x2-g2*x1+g3*x0;
        
        //------------------- ПОВОРАЧИВАЕМ ТЕКУЩИЙ КВАТЕРНИОН УГЛОВОГО ПОЛОЖЕНИЯ -------------
        
        //======================== ВЫВОД УГЛОВ ЧЕРЕЗ ЛИНЕЙНЫЕ УСКОРЕНИЯ =====================        
        
        N=sqrt(Nx*Nx+Ny*Ny+Nz*Nz);
        pitch_n=180*asin(Nx/N)/M_PI;  
        roll_n=180*atan2(-Nz,Ny)/M_PI;       
        
        //------------------------ ВЫВОД УГЛОВ ЧЕРЕЗ ЛИНЕЙНЫЕ УСКОРЕНИЯ ---------------------  
        
        //=================== ПРОЕЦИРОВАНИЕ МАГНИТНОЙ ИНДУКЦИИ НА ГОРИЗОНТ ===================

        
        double pitch_in_rad=M_PI*pitch/180;
        double roll_in_rad=M_PI*roll/180;
       
        Bxg = Bx*cos(pitch_in_rad)+Bz*sin(pitch_in_rad)*sin(roll_in_rad)-By*sin(pitch_in_rad)*cos(roll_in_rad);
        Bzg = By*sin(roll_in_rad)+Bz*cos(roll_in_rad);
        
        heading_m=180*atan2(Bzg,Bxg)/M_PI;
        if (heading_m < 0) {heading_m+=360;}
       
    

        //------------------- ПРОЕЦИРОВАНИЕ МАГНИТНОЙ ИНДУКЦИИ НА ГОРИЗОНТ -------------------    
                 
        //======================== КОРРЕКТИРОВКА ПО ДАННЫМ АКСЕЛЕРОМЕТРА  ====================
        
        GET_QUATERNION((heading+magnet_correction*(heading_m-heading)),roll_n,pitch_n);//получение кватерниона углового положения через данные с акселерометра и магнитометра
        
        double q_norm;//норма кватерниона   
        double scal_multiply;//скалярное произведение кватернионов
        

        scal_multiply=x0*gc0+x1*gc1+x2*gc2+x3*gc3;//определяем угловое расстояние между векторами поворота
        
        if (scal_multiply>=0)//смешивание значений с дуса и (акселя с магнитометром)
        {
            gi0=x0*(1-filter_k)+gc0*filter_k;
            gi1=x1*(1-filter_k)+gc1*filter_k;
            gi2=x2*(1-filter_k)+gc2*filter_k;
            gi3=x3*(1-filter_k)+gc3*filter_k;
        }
        else 
        {
            gi0=x0*(1-filter_k)-gc0*filter_k;
            gi1=x1*(1-filter_k)-gc1*filter_k;
            gi2=x2*(1-filter_k)-gc2*filter_k;
            gi3=x3*(1-filter_k)-gc3*filter_k;
        }
     
        q_norm=1/(sqrt(gi0*gi0+gi1*gi1+gi2*gi2+gi3*gi3)); //нормируем результирующий кватернион
        gi0=gi0*q_norm;
        gi1=gi1*q_norm;
        gi2=gi2*q_norm;
        gi3=gi3*q_norm;
        
        //------------------------ КОРРЕКТИРОВКА ПО ДАННЫМ АКСЕЛЕРОМЕТРА  --------------- 
 
           
        
       
//================================= РАСЧЁТ УГЛОВ ===================================

        roll=180*atan2(-(2*gi2*gi3-2*gi0*gi1),(2*gi0*gi0+2*gi2*gi2-1))/M_PI;
        heading=180*atan2(-(2*gi1*gi3-2*gi0*gi2),(2*gi1*gi1+2*gi0*gi0-1))/M_PI;
        if (heading < 0) {heading+=360;}
        pitch=180*asin(2*gi1*gi2+2*gi0*gi3)/M_PI;       
        
//--------------------------------- РАСЧЁТ УГЛОВ ------------------------------------
      

//====================== ПРОЕЦИРОВАНИЕ УСКОРЕНИЙ НА ОСИ ИСК =========================

        Nxg=Nx*(gi0*gi0+gi1*gi1-gi2*gi2-gi3*gi3)+Ny*(2*gi1*gi2-2*gi0*gi3)+Nz*(2*gi1*gi3+2*gi0*gi2);
        Nyg=Nx*(2*gi1*gi2+2*gi0*gi3)+Ny*(gi0*gi0-gi1*gi1+gi2*gi2-gi3*gi3)+Nz*(2*gi2*gi3-2*gi0*gi1);
        Nzg=Nx*(2*gi1*gi3-2*gi0*gi2)+Ny*(2*gi2*gi3+2*gi0*gi1)+Nz*(gi0*gi0-gi1*gi1-gi2*gi2+gi3*gi3);
        

//---------------------- ПРОЕЦИРОВАНИЕ УСКОРЕНИЙ НА ОСИ ИСК -------------------------
 
//------------------------------------ КВАТЕРНИОНЫ ----------------------------------     
       
//================================= ОТВЕТ ПО ШИНЕ I2C ===============================          
        DATA_SPLITTING ();            
        final_of_cycle=1;                       //расчёт завершён, взводим флаг         
        n_byte_i2c=0;              
        I2C_ALLOW_ANSWER();                     //Запуск I2C, разрешаем отвечать на запросы мастера         
        
        while (SysTick->VAL>safe_time);         //минимальное время на работу по шине I2C               
       
        I2C_RESTRICT_ANSWER();                  //Останов шины I2C, запрет прерываний по условиям выхода из времени такта 
   
        while(lock_cycle){}                     //ждём завершение отсечки по времени
        
    }
    
//--------------------------------- ОТВЕТ ПО ШИНЕ I2C -------------------------------    

}

//----------------------------------- ОСНОВНОЙ БЛОК --------------------------------
